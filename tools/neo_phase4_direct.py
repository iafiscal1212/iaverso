#!/usr/bin/env python3
"""
NEO Phase 4 Direct Modifier
===========================

Directly modifies NEO's intention via the state file between cycles.
This ensures real variance is generated by Phase 4.

Strategy:
1. Run NEO step to get natural evolution
2. Load state, compute Phase 4 perturbation
3. Modify intention in state file
4. Next step reads modified state
5. Repeat to generate variance
"""

import sys
import os
import json
import math
import time
import urllib.request
from datetime import datetime
from pathlib import Path
import numpy as np
import yaml

sys.path.insert(0, '/root/NEO_EVA/tools')
from phase4_variability import Phase4Controller

# Config
NEO_URL = "http://127.0.0.1:7777"
NEO_STATE = "/root/NEOSYNT/state/neo_state.yaml"


def server_request(endpoint, method='GET', data=None, timeout=10):
    """Make request to NEO server."""
    url = f'{NEO_URL}{endpoint}'
    try:
        if data:
            req = urllib.request.Request(
                url,
                data=json.dumps(data).encode(),
                headers={'Content-Type': 'application/json'},
                method=method
            )
        else:
            req = urllib.request.Request(url, method=method)
        response = urllib.request.urlopen(req, timeout=timeout)
        return json.loads(response.read().decode())
    except Exception as e:
        print(f"  [Error] {endpoint}: {e}")
        return None


def load_neo_state():
    """Load NEO state from YAML file."""
    if not os.path.exists(NEO_STATE):
        return None
    with open(NEO_STATE) as f:
        return yaml.safe_load(f)


def save_neo_state(state):
    """Save NEO state to YAML file."""
    with open(NEO_STATE, 'w') as f:
        yaml.dump(state, f, default_flow_style=False)


def get_intention_from_state(state):
    """Extract current intention from state."""
    daemon = state.get('daemon', {})
    I = daemon.get('I', [1/3, 1/3, 1/3])
    return np.array(I)


def set_intention_in_state(state, I_new):
    """Set intention in state dict."""
    if 'daemon' not in state:
        state['daemon'] = {}
    state['daemon']['I'] = I_new.tolist()

    # Also update autonomy current_intention
    if 'autonomy' not in state:
        state['autonomy'] = {}
    state['autonomy']['current_intention'] = I_new.tolist()


def get_history_from_state(state):
    """Extract intention history from state."""
    hist = state.get('autonomy', {}).get('history_intention', [])
    return [np.array(v) for v in hist if len(v) == 3]


def compute_sigmas(I_history):
    """Compute historical sigmas from intention history."""
    if len(I_history) < 10:
        # Use initial perturbation scale
        return (0.01, 0.01, 0.01)

    I_arr = np.array(I_history)

    # Use IQR-based sigma for robustness
    sig_S = float(np.percentile(I_arr[:, 0], 75) - np.percentile(I_arr[:, 0], 25)) / 1.35
    sig_N = float(np.percentile(I_arr[:, 1], 75) - np.percentile(I_arr[:, 1], 25)) / 1.35
    sig_C = float(np.percentile(I_arr[:, 2], 75) - np.percentile(I_arr[:, 2], 25)) / 1.35

    # Floor for extreme equilibrium - use sqrt(T) scaling
    T = len(I_history)
    floor = 0.01 / math.sqrt(T)  # Decreasing floor as T grows

    return (max(sig_S, floor), max(sig_N, floor), max(sig_C, floor))


def mirror_descent_step(I_current, delta, eta=0.1):
    """
    Apply mirror descent to stay in simplex.

    I_{t+1} = softmax(log(I_t) + η * δ)
    """
    eps = 1e-10
    I_safe = np.clip(I_current, eps, 1 - eps)

    log_I = np.log(I_safe)
    log_I_new = log_I + eta * delta

    # Softmax projection
    exp_log = np.exp(log_I_new - np.max(log_I_new))
    I_new = exp_log / np.sum(exp_log)

    return I_new


def run_phase4_direct(cycles=200, perturbation_scale=0.05, sample_every=5):
    """
    Run NEO cycles with direct Phase 4 perturbation.

    Modifies intention directly in state file between cycles.
    """
    print("=" * 70)
    print("Phase 4 Direct Modifier")
    print("=" * 70)
    print(f"Cycles: {cycles}")
    print(f"Perturbation scale: {perturbation_scale}")
    print(f"Sample every: {sample_every}")
    print()

    # Check server
    health = server_request('/health')
    if not health:
        print("ERROR: NEO server not running")
        return None

    print(f"Server OK: t={health.get('t', '?')}")

    # Load initial state
    state = load_neo_state()
    if not state:
        print("ERROR: Cannot load NEO state file")
        return None

    I_history = get_history_from_state(state)
    print(f"History loaded: {len(I_history)} points")

    # Create Phase 4 controller
    controller = Phase4Controller()

    # Get initial status via API
    status = server_request('/status')
    I_initial = np.array([
        status['intention']['S'],
        status['intention']['N'],
        status['intention']['C']
    ])
    print(f"\nInitial I: [{I_initial[0]:.6f}, {I_initial[1]:.6f}, {I_initial[2]:.6f}]")

    # Series for recording
    series = []
    perturbations = []

    print(f"\n--- Running {cycles} cycles with Phase 4 direct modification ---\n")

    for i in range(cycles):
        # Run a NEO step first (natural evolution)
        step_result = server_request('/step', method='POST')
        if not step_result:
            print(f"Cycle {i}: Step failed")
            time.sleep(0.5)
            continue

        # Small delay to ensure file is written
        time.sleep(0.05)

        # Reload state after step
        state = load_neo_state()
        if not state:
            continue

        I_current = get_intention_from_state(state)
        t = state.get('daemon', {}).get('cycle_count', i)

        # Update history
        I_history = get_history_from_state(state)
        sigmas = compute_sigmas(I_history)

        # Compute residuals from recent changes
        if len(I_history) >= 5:
            recent = I_history[-10:]
            diffs = [np.linalg.norm(recent[j+1] - recent[j]) for j in range(len(recent)-1)]
            residuals = np.array(diffs) if diffs else np.array([1e-6])
        else:
            residuals = np.array([sigmas[0], sigmas[1], sigmas[2]])

        # Update Jacobian info if not yet done (marginally stable system)
        if controller._last_J is None:
            # Use pre-computed Jacobian from analysis
            J = np.array([
                [0.75, -0.16, -0.34],
                [-0.25, 0.70, -0.20],
                [-0.25, -0.29, 0.79]
            ])
            controller.update_jacobian(J, 0.9945)

        # ACF lag estimation from residuals
        acf_lag = max(5, int(math.sqrt(len(I_history) + 1)))
        window_size = max(10, int(math.sqrt(len(I_history) + 1) * 2))

        # Phase 4 computation (I_current, I_predicted, sigmas, acf_lag, window_size)
        I_predicted = I_current.copy()  # Persistence prediction
        I_phase4, diag = controller.step(
            I_current, I_predicted, sigmas, acf_lag, window_size
        )

        delta_phase4 = I_phase4 - I_current
        delta_norm = np.linalg.norm(delta_phase4)

        # Apply perturbation if Phase 4 is active
        I_modified = I_current.copy()
        applied_delta = 0.0

        if diag.get('phase4_active', False):
            # Scale delta by perturbation_scale for controlled variance
            # Use tau from Phase 4 as adaptive scale
            tau = diag.get('tau', perturbation_scale)
            effective_scale = min(perturbation_scale, tau * 10)

            # Compute tangent plane perturbation
            # u_c is coherence direction, u_perp is perpendicular
            u_perp = diag.get('ou_Z', np.random.randn(2))
            if isinstance(u_perp, list):
                u_perp = np.array(u_perp)

            # Generate perturbation in tangent plane
            # Use OU process output as direction
            if len(u_perp) >= 2:
                # Map 2D tangent space to 3D simplex perturbation
                # Direction: mostly toward N,C (away from S=1 attractor)
                delta_tangent = np.array([
                    -u_perp[0] * 0.5,  # Reduce S
                    u_perp[0] * 0.3 + u_perp[1] * 0.3,  # Increase N
                    u_perp[1] * 0.4   # Increase C
                ])

                # Normalize and scale
                delta_tangent = delta_tangent / (np.linalg.norm(delta_tangent) + 1e-10)
                delta_tangent *= effective_scale

                # Apply via mirror descent
                I_modified = mirror_descent_step(I_current, delta_tangent, eta=1.0)
                applied_delta = np.linalg.norm(I_modified - I_current)

                # Update state file with modified intention
                set_intention_in_state(state, I_modified)
                save_neo_state(state)

                perturbations.append({
                    't': t,
                    'delta_tangent': delta_tangent.tolist(),
                    'applied_delta': applied_delta,
                    'tau': tau,
                    'I_before': I_current.tolist(),
                    'I_after': I_modified.tolist()
                })

        # Record sample
        if i % sample_every == 0:
            sample = {
                "t": t,
                "S": float(I_current[0]),
                "N": float(I_current[1]),
                "C": float(I_current[2]),
                "S_mod": float(I_modified[0]),
                "N_mod": float(I_modified[1]),
                "C_mod": float(I_modified[2]),
                "phase4_active": diag.get("phase4_active", False),
                "tau": diag.get("tau", 0),
                "delta_phase4": delta_norm,
                "delta_applied": applied_delta,
                "eci": step_result.get('eci', 0),
                "sigmas": list(sigmas)
            }
            series.append(sample)

            status_str = "ON " if diag.get('phase4_active') else "off"
            print(f"  t={t}: I=[{I_current[0]:.4f}, {I_current[1]:.4f}, {I_current[2]:.4f}] "
                  f"→ [{I_modified[0]:.4f}, {I_modified[1]:.4f}, {I_modified[2]:.4f}] "
                  f"P4={status_str} δ={applied_delta:.4f}")

    # Final status
    final_status = server_request('/status')
    I_final = None
    if final_status:
        I_final = [
            final_status['intention']['S'],
            final_status['intention']['N'],
            final_status['intention']['C']
        ]
        print(f"\nFinal I: [{I_final[0]:.6f}, {I_final[1]:.6f}, {I_final[2]:.6f}]")

    # Compute variance from series
    if len(series) > 5:
        S_vals = [s['S_mod'] for s in series]
        N_vals = [s['N_mod'] for s in series]
        C_vals = [s['C_mod'] for s in series]

        var_S = np.var(S_vals)
        var_N = np.var(N_vals)
        var_C = np.var(C_vals)

        print(f"\n--- Variance Analysis ---")
        print(f"Var(S): {var_S:.6e}")
        print(f"Var(N): {var_N:.6e}")
        print(f"Var(C): {var_C:.6e}")
        print(f"Total Var: {var_S + var_N + var_C:.6e}")

    # Diagnostics
    print(f"\n--- Phase 4 Diagnostics ---")
    full_diag = controller.get_full_diagnostics()
    print(f"Total calls: {full_diag['total_calls']}")
    print(f"Activations: {full_diag['activations']}")
    print(f"Rate: {full_diag['activation_rate']*100:.1f}%")
    print(f"Perturbations applied: {len(perturbations)}")

    # Save results
    results = {
        "timestamp": datetime.now().isoformat(),
        "cycles": cycles,
        "perturbation_scale": perturbation_scale,
        "initial_I": I_initial.tolist(),
        "final_I": I_final,
        "series": series,
        "perturbations": perturbations,
        "diagnostics": full_diag,
        "variance": {
            "S": float(np.var([s['S_mod'] for s in series])) if series else 0,
            "N": float(np.var([s['N_mod'] for s in series])) if series else 0,
            "C": float(np.var([s['C_mod'] for s in series])) if series else 0,
        }
    }

    out_path = "/root/NEO_EVA/results/phase4_direct_run.json"
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, 'w') as f:
        json.dump(results, f, indent=2, default=str)
    print(f"\n[OK] Saved: {out_path}")

    return results


def main():
    import argparse
    parser = argparse.ArgumentParser(description="Run NEO with Phase 4 direct modification")
    parser.add_argument("--cycles", type=int, default=200, help="Number of cycles")
    parser.add_argument("--scale", type=float, default=0.05, help="Perturbation scale")
    parser.add_argument("--sample-every", type=int, default=5, help="Sample frequency")
    args = parser.parse_args()

    run_phase4_direct(
        cycles=args.cycles,
        perturbation_scale=args.scale,
        sample_every=args.sample_every
    )


if __name__ == "__main__":
    main()
