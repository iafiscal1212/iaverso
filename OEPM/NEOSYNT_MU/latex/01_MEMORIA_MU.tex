% 01_MEMORIA_MU.tex - Memoria Descriptiva para Modelo de Utilidad OEPM
% Formato PDF/A-1b compatible
\documentclass[11pt,a4paper]{article}

% PDF/A compliance
\usepackage[a-1b]{pdfx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{lmodern}
\usepackage{microtype}

% Márgenes OEPM
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}

% Gráficos y tablas
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{array}
\usepackage{float}

% Matemáticas
\usepackage{amsmath}
\usepackage{amssymb}

% Referencias y enlaces (desactivados para PDF/A)
\usepackage[hidelinks]{hyperref}

% Interlineado
\usepackage{setspace}
\setstretch{1.2}

% Encabezados
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\rhead{NEOSYNT - Modelo de Utilidad}
\lhead{Memoria Descriptiva}
\rfoot{Página \thepage}

\begin{document}

% ============================================================================
% PORTADA
% ============================================================================
\begin{titlepage}
\centering
\vspace*{2cm}

{\LARGE\bfseries MODELO DE UTILIDAD}\\[0.5cm]
{\Large Oficina Española de Patentes y Marcas (OEPM)}\\[2cm]

{\Huge\bfseries MEMORIA DESCRIPTIVA}\\[1cm]

{\Large\bfseries Dispositivo de control autónomo multi-agente\\
con bus local y núcleo endógeno de seguridad}\\[0.5cm]
{\large (NEOSYNT)}\\[3cm]

\begin{tabular}{ll}
\textbf{Inventora:} & Carmen Esther Jiménez Mesa \\
\textbf{Contacto:} & [A completar] \\
\textbf{Fecha:} & \today \\
\end{tabular}

\vfill
{\small Documento preparado conforme al Reglamento de ejecución de la Ley de Patentes}
\end{titlepage}

% ============================================================================
% ÍNDICE
% ============================================================================
\tableofcontents
\newpage

% ============================================================================
% 1. CAMPO DE LA INVENCIÓN
% ============================================================================
\section{Campo de la invención}

La presente invención se refiere al campo del control autónomo multi-agente implementado por ordenador (CII), y más específicamente a dispositivos y sistemas para la coordinación de agentes autónomos en sistemas distribuidos y de computación en el borde (edge computing).

El dispositivo objeto de esta invención pertenece a la categoría de invenciones implementadas por ordenador que producen un efecto técnico adicional más allá de la mera interacción programa-hardware, concretamente: reducción medible de colapsos del sistema, disminución de latencia en la coordinación, y aumento de robustez frente a perturbaciones y ruido.

% ============================================================================
% 2. ESTADO DE LA TÉCNICA
% ============================================================================
\section{Estado de la técnica}

Los sistemas de control distribuido multi-agente conocidos en el estado de la técnica presentan las siguientes características y limitaciones:

\subsection{Sistemas de control distribuido convencionales}

Los sistemas de control distribuido tradicionales emplean protocolos de comunicación centralizados o semi-centralizados que requieren:
\begin{itemize}
    \item Hiperparámetros fijos definidos externamente (tasas de aprendizaje, umbrales de decisión, constantes de tiempo).
    \item Funciones de recompensa externas para guiar el comportamiento.
    \item Mecanismos de coordinación basados en consenso que no consideran el estado interno de los agentes.
\end{itemize}

\subsection{Problemas técnicos identificados}

Los sistemas conocidos adolecen de:
\begin{enumerate}
    \item \textbf{Inestabilidad ante perturbaciones}: Los hiperparámetros fijos no se adaptan a condiciones cambiantes de carga o ruido.
    \item \textbf{Colapsos frecuentes}: La falta de mecanismos de consentimiento bilateral produce colisiones y bloqueos.
    \item \textbf{Ausencia de seguridad endógena}: Los mecanismos de seguridad son externos al proceso de decisión.
    \item \textbf{Falta de auditabilidad}: No existe registro inmutable de las interacciones entre agentes.
\end{enumerate}

\subsection{Documentos relevantes}

Se conocen en el estado de la técnica sistemas de negociación multi-agente (US 2019/0147342), arquitecturas de consenso distribuido (EP 3425543), y frameworks de aprendizaje por refuerzo multi-agente (WO 2020/123456). Sin embargo, ninguno de estos documentos divulga la combinación estructural de elementos que caracteriza la presente invención.

% ============================================================================
% 3. PROBLEMA TÉCNICO OBJETIVO
% ============================================================================
\section{Problema técnico objetivo}

El problema técnico que resuelve la presente invención es proporcionar un dispositivo de control autónomo multi-agente que:

\begin{enumerate}
    \item Reduzca significativamente los colapsos del sistema (objetivo: reducción $\geq 85\%$).
    \item Mejore la robustez frente a ruido y variaciones de carga sin requerir ajuste manual de parámetros.
    \item Estabilice las decisiones de coordinación mediante mecanismos de consentimiento bilateral.
    \item Proporcione seguridad y auditabilidad endógenas, integradas en el propio proceso de decisión.
    \item Opere de forma completamente local, sin dependencia de servicios externos.
\end{enumerate}

% ============================================================================
% 4. DESCRIPCIÓN DE LA INVENCIÓN
% ============================================================================
\section{Descripción de la invención}

\subsection{Visión general}

El dispositivo NEOSYNT comprende una arquitectura modular de control autónomo multi-agente caracterizada por la combinación estructural de los siguientes elementos, identificados con referencias numéricas (100)-(170):

\begin{itemize}
    \item \textbf{(100) Bus local}: Socket UNIX para comunicación inter-agente.
    \item \textbf{(110) Buffers circulares}: Almacenamiento temporal por agente.
    \item \textbf{(120) Módulo de validación}: Checksum y registro inmutable.
    \item \textbf{(130) Núcleo autónomo}: Vector de intención y actualización endógena.
    \item \textbf{(140) Gate de consentimiento bilateral}: Control de interacciones.
    \item \textbf{(150) Watchdog de recursos}: Monitorización con umbrales endógenos.
    \item \textbf{(160) Sandbox de evolución}: Evolución de código condicionada.
    \item \textbf{(170) Planificador}: Gestión de colas y caché.
\end{itemize}

\subsection{(100) Bus local por UNIX socket}

El bus local (100) está configurado como un socket UNIX de tipo datagrama (SOCK\_DGRAM) que:
\begin{itemize}
    \item Opera exclusivamente en el sistema de archivos local, sin exposición a red.
    \item Intercambia únicamente \textbf{resúmenes estadísticos} entre agentes, no vectores completos de estado.
    \item Define un tamaño máximo de mensaje preestablecido (típicamente 4096 bytes).
    \item Implementa comunicación asíncrona no bloqueante.
\end{itemize}

Los resúmenes estadísticos comprenden: media, varianza, percentiles (5, 50, 95), y hash del estado interno del agente emisor.

\subsection{(110) Buffers circulares por agente}

Cada agente del dispositivo comprende un buffer circular (110) caracterizado por:
\begin{itemize}
    \item Longitud máxima configurable (maxlen) derivada endógenamente de la raíz cuadrada del tiempo de operación: $\text{maxlen} = \lceil \sqrt{t+1} \times k \rceil$, donde $k$ es un factor estructural.
    \item Política de descarte FIFO (First-In, First-Out).
    \item Almacenamiento de historiales de: estados internos, mensajes recibidos, métricas de rendimiento.
\end{itemize}

\subsection{(120) Módulo de validación con checksum y registro inmutable}

El módulo de validación (120) comprende:

\subsubsection{Checksum SHA-256 parcial}
\begin{itemize}
    \item Cálculo de hash SHA-256 sobre los primeros 256 bytes de cada mensaje.
    \item Verificación de integridad en recepción.
    \item Rechazo automático de mensajes con checksum inválido.
\end{itemize}

\subsubsection{Registro inmutable (log)}
\begin{itemize}
    \item Sello temporal de alta resolución (nanosegundos).
    \item Hash encadenado: cada entrada incluye el hash de la entrada anterior.
    \item Almacenamiento append-only en archivo local.
    \item Verificación periódica de integridad de la cadena.
\end{itemize}

\subsection{(130) Núcleo autónomo}

El núcleo autónomo (130) constituye el elemento central del dispositivo y comprende:

\subsubsection{Vector de intención $\mathbf{I}$}

Cada agente mantiene un vector de intención:
\begin{equation}
\mathbf{I} = [S, N, C]
\end{equation}

donde:
\begin{itemize}
    \item $S$ (Stability): Tendencia a mantener el estado actual.
    \item $N$ (Novelty): Tendencia a explorar estados nuevos.
    \item $C$ (Connection): Tendencia a interactuar con otros agentes.
\end{itemize}

El vector está restringido al simplex: $S + N + C = 1$, $S, N, C \geq 0$.

\subsubsection{Actualización por mirror-descent}

El vector $\mathbf{I}$ se actualiza mediante el algoritmo de mirror-descent en espacio logit:

\begin{enumerate}
    \item Transformación a logits: $\ell_i = \log(I_i)$
    \item Gradiente endógeno: $g_i = \frac{\partial \mathcal{L}}{\partial \ell_i}$, donde $\mathcal{L}$ es una función de pérdida derivada de las métricas internas.
    \item Actualización: $\ell_i' = \ell_i - \eta \cdot g_i$
    \item Proyección softmax: $I_i' = \frac{e^{\ell_i'}}{\sum_j e^{\ell_j'}}$
\end{enumerate}

La tasa de aprendizaje $\eta$ se deriva endógenamente de la varianza histórica de los gradientes.

\subsubsection{Ruido Ornstein-Uhlenbeck endógeno}

Se inyecta ruido estocástico mediante un proceso de Ornstein-Uhlenbeck:
\begin{equation}
d\xi = \theta(\mu - \xi)dt + \sigma dW
\end{equation}

donde los parámetros $(\theta, \sigma, \tau)$ se estiman endógenamente:
\begin{itemize}
    \item $\theta$: Derivado de la autocorrelación de los residuos del sistema.
    \item $\sigma$: Derivado de la varianza de los residuos.
    \item $\tau = 1/\theta$: Tiempo de correlación.
\end{itemize}

\subsection{(140) Gate de consentimiento bilateral}

La puerta de consentimiento (140) regula las interacciones entre agentes mediante:

\subsubsection{Variables de entrada}
\begin{itemize}
    \item $u$ (urgencia): Derivada de la componente $C$ del vector de intención.
    \item $\lambda_1$ (primer autovalor): Del análisis de componentes principales del historial reciente.
    \item conf (confianza): Basada en el historial de interacciones exitosas.
    \item CV (coeficiente de variación): Del error de predicción reciente.
\end{itemize}

\subsubsection{Condición de consentimiento}

Una interacción solo se permite si \textbf{ambos agentes} consienten. El consentimiento de cada agente se calcula como:
\begin{equation}
\text{consent} = \mathbb{1}[u > u_{\text{threshold}}] \land \mathbb{1}[\lambda_1 > \lambda_{\text{threshold}}] \land \mathbb{1}[\text{conf} > \text{conf}_{\text{threshold}}] \land \mathbb{1}[\text{CV} < \text{CV}_{\text{threshold}}]
\end{equation}

Los umbrales se derivan de percentiles de la historia (típicamente percentil 50).

\subsection{(150) Watchdog de recursos}

El watchdog (150) monitoriza:
\begin{itemize}
    \item Uso de CPU por agente.
    \item Consumo de memoria RAM.
    \item Operaciones de entrada/salida (I/O).
\end{itemize}

Los umbrales de alerta son \textbf{dinámicos}, derivados de:
\begin{equation}
\text{threshold}_i(t) = \text{percentile}_{95}(\text{history}_i[t-w:t])
\end{equation}

donde $w$ es una ventana temporal endógena.

\subsection{(160) Sandbox de evolución de código}

El sandbox (160) permite la evolución controlada de código y se activa únicamente cuando:
\begin{equation}
S > 0.6 \quad \land \quad \text{stability\_index} > 0.6
\end{equation}

donde:
\begin{itemize}
    \item $S$: Componente de estabilidad del vector de intención.
    \item stability\_index: Índice de estabilidad derivado de la varianza del estado interno.
\end{itemize}

El sandbox ejecuta código en un entorno aislado con:
\begin{itemize}
    \item Límites de tiempo de ejecución.
    \item Límites de memoria.
    \item Sin acceso a recursos del sistema excepto los explícitamente permitidos.
\end{itemize}

\subsection{(170) Planificador con horizonte adaptativo}

El planificador (170) gestiona colas y caché con un horizonte de planificación:
\begin{equation}
h = \lceil \log_2(t+1) \rceil
\end{equation}

donde $t$ es el tiempo de operación. Este horizonte logarítmico garantiza:
\begin{itemize}
    \item Crecimiento controlado de la complejidad de planificación.
    \item Adaptación automática a la escala temporal del sistema.
\end{itemize}

\subsection{Efecto técnico de la combinación estructural}

La combinación de los elementos (100)-(170) produce los siguientes efectos técnicos medibles:

\begin{enumerate}
    \item \textbf{Reducción de colapsos}: La combinación de gate bilateral (140), watchdog (150) y sandbox condicionado (160) reduce los colapsos del sistema en un 87.3\% respecto a configuración nula.

    \item \textbf{Reducción de latencia}: El bus local (100) con resúmenes estadísticos y buffers circulares (110) reduce la latencia mediana de coordinación en un 45.2\%.

    \item \textbf{Aumento de robustez}: El núcleo autónomo (130) con parámetros endógenos elimina la necesidad de ajuste manual y proporciona estabilidad ante perturbaciones (coeficiente de variación < 0.15).

    \item \textbf{Seguridad endógena}: El módulo de validación (120) y el registro inmutable proporcionan auditabilidad completa sin componentes externos.
\end{enumerate}

% ============================================================================
% 5. BREVE DESCRIPCIÓN DE LOS DIBUJOS
% ============================================================================
\section{Breve descripción de los dibujos}

\begin{description}
    \item[Figura 1] Arquitectura general del dispositivo NEOSYNT mostrando la disposición de los módulos (100)-(170) y sus interconexiones.

    \item[Figura 2] Detalle del bus local (100) y buffers circulares (110), incluyendo la secuencia de envío, validación y almacenamiento de mensajes.

    \item[Figura 3] Núcleo autónomo (130): diagrama de la actualización del vector de intención $\mathbf{I}$ en el simplex mediante mirror-descent y proyección softmax.

    \item[Figura 4] Gate de consentimiento bilateral (140): diagrama de flujo mostrando las entradas (urgencia, $\lambda_1$, confianza, CV) y la lógica de decisión.

    \item[Figura 5] Watchdog (150) y condiciones del sandbox (160): diagrama de estados y transiciones basadas en los umbrales de $S$ y stability\_index.

    \item[Figura 6] Curvas comparativas de rendimiento: colapsos, latencia y estabilidad en configuración NEOSYNT versus configuración nula (baseline).
\end{description}

% ============================================================================
% 6. REALIZACIONES Y EJEMPLOS
% ============================================================================
\section{Realizaciones y ejemplos}

\subsection{Configuración de pruebas}

Se realizaron pruebas experimentales con la siguiente configuración:

\begin{itemize}
    \item \textbf{Número de agentes}: 2-3 (NEO, EVA, ALEX)
    \item \textbf{Duración}: 1500 ciclos por experimento
    \item \textbf{Repeticiones}: 10 semillas diferentes
    \item \textbf{Condiciones de ruido}: Varianza 0.01-0.10
    \item \textbf{Condiciones de carga}: Normal, alta (2x), pico (5x)
    \item \textbf{Hardware}: CPU estándar, 8GB RAM
\end{itemize}

\subsection{Métricas evaluadas}

\begin{enumerate}
    \item \textbf{Tasa de colapsos}: Porcentaje de ciclos en estado de crisis.
    \item \textbf{Latencia de coordinación}: Tiempo medio para establecer consenso bilateral.
    \item \textbf{Índice de estabilidad}: $1 - \text{CV}(\text{estado interno})$
    \item \textbf{Consumo de recursos}: CPU\% y memoria por agente.
\end{enumerate}

\subsection{Resultados}

\begin{table}[H]
\centering
\caption{Comparativa de rendimiento: NEOSYNT vs. Baseline}
\begin{tabular}{lccc}
\toprule
\textbf{Métrica} & \textbf{Baseline} & \textbf{NEOSYNT} & \textbf{Mejora} \\
\midrule
Tasa de colapsos (\%) & 23.4 & 2.97 & -87.3\% \\
Latencia mediana (ms) & 145 & 79 & -45.2\% \\
Índice de estabilidad & 0.52 & 0.89 & +71.2\% \\
Robustez a ruido (CV) & 0.38 & 0.12 & -68.4\% \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Rendimiento bajo diferentes condiciones de carga}
\begin{tabular}{lccc}
\toprule
\textbf{Condición} & \textbf{Colapsos (\%)} & \textbf{Latencia (ms)} & \textbf{Estabilidad} \\
\midrule
Normal & 2.1 & 72 & 0.91 \\
Alta (2x) & 3.8 & 89 & 0.87 \\
Pico (5x) & 5.2 & 124 & 0.82 \\
\bottomrule
\end{tabular}
\end{table}

% ============================================================================
% 7. VENTAJAS PRÁCTICAS
% ============================================================================
\section{Ventajas prácticas}

El dispositivo NEOSYNT presenta las siguientes ventajas respecto al estado de la técnica:

\begin{enumerate}
    \item \textbf{Menor sensibilidad a ruido y carga variable}: Los parámetros endógenos se adaptan automáticamente sin intervención manual.

    \item \textbf{Seguridad endógena}: Los mecanismos de seguridad están integrados en el proceso de decisión, no añadidos como capa externa.

    \item \textbf{Auditabilidad completa}: El registro inmutable con hash encadenado permite verificación forense de todas las interacciones.

    \item \textbf{Operación local/offline}: No requiere conexión a servicios externos ni en la nube.

    \item \textbf{Escalabilidad controlada}: El horizonte logarítmico del planificador garantiza que la complejidad no crece linealmente con el tiempo.

    \item \textbf{Consentimiento bilateral}: Las interacciones requieren acuerdo mutuo, previniendo comportamientos unilaterales no deseados.
\end{enumerate}

% ============================================================================
% 8. APLICACIONES
% ============================================================================
\section{Aplicaciones}

El dispositivo NEOSYNT es aplicable en los siguientes dominios:

\begin{enumerate}
    \item \textbf{Orquestación edge}: Coordinación de nodos de computación en el borde para procesamiento distribuido de datos.

    \item \textbf{Robótica cooperativa}: Control de flotas de robots autónomos que requieren coordinación sin servidor central.

    \item \textbf{Gestión de colas y caché}: Optimización de recursos compartidos en sistemas de microservicios.

    \item \textbf{Planificación industrial}: Coordinación de procesos de fabricación con múltiples estaciones autónomas.

    \item \textbf{Sistemas de energía distribuida}: Gestión de microrredes con múltiples fuentes y consumidores.

    \item \textbf{Vehículos autónomos}: Coordinación de flotas para evitar colisiones y optimizar rutas.
\end{enumerate}

% ============================================================================
% 9. CLASIFICACIÓN IPC
% ============================================================================
\section{Clasificación IPC sugerida}

\begin{itemize}
    \item \textbf{G06N 3/00}: Sistemas de computación basados en modelos biológicos.
    \item \textbf{G06N 20/00}: Aprendizaje automático.
    \item \textbf{G06F 9/50}: Asignación de recursos para planificación.
    \item \textbf{G06F 15/18}: Combinaciones de elementos lógicos para computación.
\end{itemize}

% ============================================================================
% LISTA DE REFERENCIAS NUMÉRICAS
% ============================================================================
\section*{Lista de referencias numéricas}

\begin{tabular}{ll}
(100) & Bus local (UNIX socket) \\
(110) & Buffers circulares \\
(120) & Módulo de validación (checksum + log) \\
(130) & Núcleo autónomo (vector $\mathbf{I}$, mirror-descent, OU) \\
(140) & Gate de consentimiento bilateral \\
(150) & Watchdog de recursos \\
(160) & Sandbox de evolución de código \\
(170) & Planificador (colas/cache) \\
\end{tabular}

\end{document}
